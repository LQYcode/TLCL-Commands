# Redirection   

  - cat – Concatenate files 
  - sort – Sort lines of text   
  - uniq – Report or omit repeated lines    
  - grep – Print lines matching a pattern   
  - wc – Print newline, word, and byte counts for each file 
  - head – Output the first part of a file  
  - tail – Output the last part of a file   
  - tee – Read from standard input and write to standard output and files   
  
  ## Redirecting Standard Output    
  
  I/O redirection allows us to redefine where standard output goes. To redirect standard
  output to another file instead of the screen, we use the > redirection operator followed by
  the name of the file. Why would we want to do this? It's often useful to store the output of
  a command in a file. For example, we could tell the shell to send the output of the ls
  command to the file ls-output.txt instead of the screen:
  `ls -l /usr/bin > ls-output.txt`  
  ` ls -l ls-output.txt`  
  ` less ls-output.txt`  
  `  ls -l /bin/usr > ls-output.txt `
  
  The file now has zero length! This is because when we redirect output with the “>” redirection operator, the destination file is always rewritten from the beginning. Since our ls
  command generated no results and only an error message, the redirection operation
  started to rewrite the file and then stopped because of the error, resulting in its truncation.
  In fact, if we ever need to actually truncate a file (or create a new, empty file), we can use
  a trick like this:    
    
   `> ls-output.txt` 
  
  So, how can we append redirected output to a file instead of overwriting the file from the
  beginning? For that, we use the >> redirection operator, like so:
  
  ` ls -l /usr/bin >> ls-output.txt`   
  Using the >> operator will result in the output being appended to the file. If the file does
  not already exist, it is created just as though the > operator had been used.
  
   Let's put it to the test:    
  ` ls -l /usr/bin >> ls-output.txt`    
  ` ls -l /usr/bin >> ls-output.txt`    
  ` ls -l /usr/bin >> ls-output.txt`    
  ` ls -l ls-output.txt`    
  
    
    
   ## Redirecting Standard Error
   
   Redirecting standard error lacks the ease of a dedicated redirection operator. To redirect standard error we must refer to its file descriptor. A program can produce output on any of several numbered file streams. While we have referred to the first three of these file streams as standard input, output and error, the shell references them internally as file descriptors 0, 1, and 2, respectively. The shell provides a notation for redirecting files using the file descriptor number.    
   we can redirect standard error with this notation:   
   ` ls -l /bin/usr 2> ls-error.txt`
  
  
  #### Redirecting Standard Output and Standard Error to One File
  There are cases in which we may want to capture all of the output of a command to a single file. To do this, we must redirect both standard output and standard error at the same time. There are two ways to do this.   
  `ls -l /bin/usr > ls-output.txt 2>&1`     
  First we redirect standard output to the file ls-output.txt and then we redirect file descriptor 2 (standard error) to file descriptor 1 (standard output) using the notation 2>&1.
  **Notice that the order of the redirections is significant.** The redirection of standard error must always occur after redirecting standard output or it doesn't work.
  
  Recent versions of bash provide a second, more streamlined method for performing this combined redirection shown here:    
   `ls -l /bin/usr &> ls-output.txt`
  
   We use the single notation &> to redirect both standard output and standard error to the file ls-output.txt. We can also append the standard output and standard error streams to a single file like so:    
   ` ls -l /bin/usr &>> ls-output.txt`  
   
   #### Disposing of Unwanted Output
  The system provides a way to do this by redirecting output to a special file called “/dev/null”. This file is a system device often referred to as a bit bucket, which accepts input and does nothing with it.
  `ls -l /bin/usr 2> /dev/null`     
  
  ##### /dev/null In Unix Culture
  The bit bucket is an ancient Unix concept and because of its universality, it has appeared in many parts of Unix culture. When someone says he/she is sending your comments to /dev/null, now you know what it means. For more examples, see the [Wikipedia article on /dev/null](https://en.wikipedia.org/wiki/Null_device).
  
  
  ## Redirecting Standard Input
  
  #### cat – Concatenate Files
  `cat [file...]`  
   
  In most cases, we can think of cat as being analogous to the TYPE command in DOS.
  We can use it to display files without paging. For example, the following will display the
  contents of the file ls-output.txt:`  
  
  ` cat ls-output.txt`  
  
  Cat is often used to display short text files. Since cat can accept more than one file as
  an argument, it can also be used to join files together. Say we have downloaded a large
  file that has been split into multiple parts (multimedia files are often split this way on
  Usenet), and we want to join them back together. If the files were named:
  movie.mpeg.001 movie.mpeg.002 ... movie.mpeg.099
  we could join them back together with this command as follows:    
  
  `cat movie.mpeg.0* > movie.mpeg`  
  
  If cat is not given any arguments, it reads from standard input and since standard input
  is, by default, attached to the keyboard, it's waiting for us to type something! Try adding
  the following text and pressing Enter:    
  `cat`     
  `The quick brown fox jumped over the lazy dog.`   
  
  In the absence of filename arguments, cat copies standard input to standard output, so we see our line of text repeated.
  
  ` cat > lazy_dog.txt`     
  `The quick brown fox jumped over the lazy dog.`   
  
  Now that we know how cat accepts standard input, in addition to filename arguments,
  let's try redirecting standard input.     
  `$ cat < lazy_dog.txt`    
   `The quick brown fox jumped over the lazy dog.`  
     
   Using the < redirection operator, we change the source of standard input from the keyboard to the file lazy_dog.txt. We see that the result is the same as passing a single
   filename argument.
   
   
   ## Pipelines
   
   The capability of commands to read data from standard input and send to standard output
   is utilized by a shell feature called pipelines. Using the pipe operator | (vertical bar), the
   standard output of one command can be piped into the standard input of another.  
   `command1 | command2`    
   
   We can use less to display, page by page, the output of any command that sends its results to standard output:  
   `ls -l /usr/bin | less`  
   
   #### The Difference Between > and |